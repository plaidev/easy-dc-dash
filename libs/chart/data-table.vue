<template>
  <div class="container">
    <div class="table-paging" v-if="this.useTablePaging">
      <!--
        {{this.filteredDataSize}} selected out of {{this.cfSize}} records
      -->
      Showing <span>{{this.beginRow}}</span>-<span>{{this.endRow}}</span>
      <span> / total {{this.filteredSize}} rows</span>
      <button class="btn btn-secondary" :disabled="isFirstPage" @click="prevPage()">Prev</button>
      <button class="btn btn-secondary" :disabled="isLastPage" @click="nextPage()">Next</button>
    </div>
    <table v-on:click="onclick($event)" class="krt-dc-data-table table table-hover" :id="id"></table>
  </div>
</template>

<script lang='js'>
import d3 from 'd3'
import Base from './_base'
import Store from '../store'
import {generateExtractor} from '../utils'


function _valueAccessor(d, k) {
  return d.value[k].per !== undefined ? d.value[k].per : d.value[k]
}

// 'TypeError: n.dimension(...).bottom is not a function' occured when set d3.ascending in .order (e.g.: chart.order(d3.ascending))
// There is workaround for this -> https://github.com/dc-js/dc.js/issues/1115
// reversibleGroup: function(group) {
//   return {
//     top: function(N) {
//       return group.top(N);
//     },
//     bottom: function(N) {
//       return group.top(Infinity).slice(-N).reverse();
//     }
//   }
// }
// ...
// inspired by that code. And add _count filter.
// FIXME: easy but low performance.
function _filteredGroup(group) {
  return {
    top: function(N) {
      return group
        .order((p) => (p._count===0)? 1: 0)
        .top(N)
        .filter((d) => d.value._count > 0)
    },
    bottom: function(N) {
      return group
        .order((p) => (p._count===0)? 0: 1)
        .top(Infinity)
        .slice(-N)
        .filter((d) => d.value._count > 0)
    },
    size: function() {
      return group
        .top(Infinity)
        .filter((d) => d.value._count > 0)
        .length
    }
  }
}

export default {
  extends: Base,
  props: {
    chartType: {
      type: String,
      default: 'dataTable'
    },
    columns: {
      type: String
    },
    // row order
    sortBy: {
      type: String
    },
    order: {
      type: String,
      default: 'descending'
    },
    // chart style
    width: {
      type: Number,
      default: 1000
    },
    height: {
      type: Number,
      default: 1000
    },
    // paging
    useTablePaging: {
      type: Boolean,
      default: true
    },
    offset: {
      type: Number,
      default: 0
    },
    rowsPerPage: {
      type: Number,
      default: 10
    }
  },
  data () {
    return {
      ofs: this.offset,
      pag: this.rowsPerPage,
      cfSize: Store.getCfSize({dataset: this.dataset}),
      columnSettings: [],
      filteredDataSize: 0,
      filteredSize: 0,
      sortKey: this.sortBy,
      sortOrder: this.order
    }
  },
  watch: {
    sortKey: function(newVal) {
      this.reorder()
    },
    sortOrder: function(newVal) {
      this.reorder()
    }
  },
  computed: {
    getColsExtractor: function() {
      return generateExtractor(this.columns)
    },
    cols: function() {
      return (this.getColsExtractor)(this.firstRow)
    },
    colsKeys: function() {
      return Object.keys(this.cols)
    },
    beginRow: function() {
      return this.ofs
    },
    endRow: function() {
      let end = this.ofs + this.pag - 1
      return Math.min(end, this.filteredSize)
    },
    firstRow: function() {
      const dim = Store.registerDimension(this.dimensionName, this.getDimensionExtractor, {dataset: this.dataset});
      return dim.top(1)[0]
    },
    isFirstPage: function() {
      return ((this.ofs - this.pag) < 0) ? 'true' : null
    },
    isLastPage: function() {
      return ((this.ofs + this.pag) >= this.filteredSize) ? 'true' : null
    },
    grouping: function() {
      const dim = Store.registerDimension(this.dimensionName, this.getDimensionExtractor, {dataset: this.dataset});
      const dimensionKey = this.extractDimensionName(this.dimension);
      const grouping = dim.group().reduce(
        (p, v) => {
          const vals = this.getColsExtractor(v);
          this.colsKeys.forEach((k) => {
            if (k === dimensionKey) {
              p[k] = vals[k]
            }
            else if (vals[k].count) {
              p[k].count += vals[k].count;
              p[k].value += vals[k].value;
              p[k].per = p[k].count === 0 ? 0 : p[k].value / p[k].count;
            }
            else p[k] += vals[k]
          })
          p._count++;
          return p;
        },
        (p, v) => {
          const vals = this.getColsExtractor(v);
          this.colsKeys.forEach((k) => {
            if (k === dimensionKey) {
              p[k] = vals[k]
            }
            else if (vals[k].count) {
              p[k].count -= vals[k].count;
              p[k].value -= vals[k].value;
              p[k].per = p[k].count === 0 ? 0 : p[k].value / p[k].count;
            }
            else p[k] -= vals[k]
          })
          p._count--;
          return p;
        },
        () => {
          const p = this.getSchema()
          p._count = 0;
          return p
        }
      )
      return _filteredGroup(grouping)
    }
  },
  methods: {
    onclick: function(ev) {
      if (ev && ev.target.classList.contains('dc-table-head')) {
        let sortKey = Store.getKeyByLabel(ev.target.textContent, {dataset: this.dataset}) || ev.target.textContent
        if (this.colsKeys.indexOf(sortKey) >= 0 ) {
          if (sortKey === this.sortKey) {
            this.sortOrder = (this.sortOrder === 'descending')? 'ascending': 'descending'
          }
          else {
            this.sortKey = sortKey;
          }
        }
      }
    },
    reorder: function() {
      this.chart
        .group((d) => null)
        .size(Infinity)
        .sortBy((d) => _valueAccessor(d, this.sortKey))
        .order(d3[this.sortOrder])
        .render()
    },
    extractDimensionName: function(name) {
      return name.replace(/d\./, '')
    },
    getSchema: function() {
      const schema = {}
      this.colsKeys.forEach((k) => {
        val = this.cols[k]
        if(val instanceof String || typeof val === 'string') val = '';
        else if(val instanceof Number || typeof val === 'number') val = 0;
        else if(val instanceof Object || typeof val === 'object') {
          val = {count: 0, value:0, per:0}
        }
        Object.assign(schema, {[k]: val})
      })
      return schema
    },
    setColumnSettings: function() {
      this.colsKeys.forEach((k) => {
        this.columnSettings.push({
          label: Store.getLabel(k, {dataset: this.dataset}),
          format: (d) => d.value[k].per !== undefined ? d.value[k].per : d.value[k]
        })
      })
    },
    // paging
    updateTable: function() {
      this.chart.beginSlice(this.ofs);
      this.chart.endSlice(this.ofs + this.pag);
    },
    nextPage: function() {
      this.ofs += this.pag;
      this.updateTable();
      this.chart.redraw();
    },
    prevPage: function() {
      this.ofs -= this.pag;
      this.updateTable();
      this.chart.redraw();
    }
  },
  mounted: function() {
    this.setColumnSettings()

    const chart = this.chart;
    const sortKey = this.sortKey || this.colsKeys[0]

    chart
      .group((d) => null)
      .size(Infinity)
      .showGroups(false)
      .columns(this.columnSettings)
      .sortBy((d) => _valueAccessor(d, sortKey))
      .order(d3[this.order])
      .on('renderlet', () => {
        const dim = Store.getDimension(this.dimensionName, {dataset: this.dataset})
        this.filteredDataSize = dim.groupAll().value()
        this.filteredSize = this.grouping.size()
      })
    this.updateTable()
    return chart.render();
  }
}
</script>

<style scoped>
.container {
  display: flex;
  flex-direction: column;
}
</style>